<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Gridded | Web-Apps</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="./_observablehq/theme-air,near-midnight,alt,wide.css">
<link rel="preload" as="style" href="./_observablehq/stdlib/inputs.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="./_observablehq/theme-air,near-midnight,alt,wide.css">
<link rel="stylesheet" type="text/css" href="./_observablehq/stdlib/inputs.css">
<link rel="modulepreload" href="./_observablehq/client.js">
<link rel="modulepreload" href="./_observablehq/runtime.js">
<link rel="modulepreload" href="./_observablehq/stdlib.js">
<link rel="modulepreload" href="./_npm/d3@7.9.0/_esm.js">
<link rel="modulepreload" href="./_import/components/gridded-glyphmaps/index.min.7ebc4e68.js">
<link rel="modulepreload" href="./_observablehq/stdlib/inputs.js">
<link rel="modulepreload" href="./_npm/htl@0.3.1/_esm.js">
<link rel="modulepreload" href="./_npm/isoformat@0.2.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-array@3.2.4/_esm.js">
<link rel="modulepreload" href="./_npm/d3-axis@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-brush@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-chord@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-color@3.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-contour@4.0.2/_esm.js">
<link rel="modulepreload" href="./_npm/d3-delaunay@6.0.4/_esm.js">
<link rel="modulepreload" href="./_npm/d3-dispatch@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-drag@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-dsv@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-ease@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-fetch@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-force@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-format@3.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-geo@3.1.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-hierarchy@3.1.2/_esm.js">
<link rel="modulepreload" href="./_npm/d3-interpolate@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-path@3.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-polygon@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-quadtree@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-random@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-scale@4.0.2/_esm.js">
<link rel="modulepreload" href="./_npm/d3-scale-chromatic@3.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-selection@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-shape@3.2.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-time@3.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-time-format@4.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-timer@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-transition@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-zoom@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/internmap@2.0.3/_esm.js">
<link rel="modulepreload" href="./_npm/delaunator@5.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/robust-predicates@3.0.2/_esm.js">
<script type="module">

import {define} from "./_observablehq/client.js";
import {registerFile} from "./_observablehq/stdlib.js";

registerFile("./data/bikes.json", {"name":"./data/bikes.json","mimeType":"application/json","path":"./_file/data/bikes.9142b027.json","lastModified":1715893876235});

define({id: "4b2ac85f", outputs: ["d3","glyphMap","_setupParamFns"], body: async () => {
const [d3, {glyphMap, _setupParamFns}] = await Promise.all([import("./_npm/d3@7.9.0/_esm.js"), import("./_import/components/gridded-glyphmaps/index.min.7ebc4e68.js")]);

return {d3,glyphMap,_setupParamFns};
}});

define({id: "ef8c2df1", inputs: ["view","Inputs"], outputs: ["discretisationInput"], body: (view,Inputs) => {
const discretisationInput = view(
  Inputs.radio(["grid", "hex"], {
    value: "grid",
    label: "Discretisation Shape",
  })
);
// const discretisation = Generators.input(discretisationInput);
return {discretisationInput};
}});

define({id: "5f55c7c5", inline: true, inputs: ["glyphmap","display"], body: async (glyphmap,display) => {
display(await(
glyphmap
))
}});

define({id: "1c6a8776", inputs: ["FileAttachment"], outputs: ["bikes"], body: (FileAttachment) => {
const bikes = FileAttachment("./data/bikes.json").json();
return {bikes};
}});

define({id: "b3d45b28", body: () => {
// const canvas = document.getElementById("myCanvas");
// const containerNode = document.getElementById("map");
}});

define({id: "6cd10b9d", inputs: ["glyphMap","bikes","discretisationInput","_setupParamFns","d3","invalidation","display"], outputs: ["glyphmap"], body: (glyphMap,bikes,discretisationInput,_setupParamFns,d3,invalidation,display) => {
const glyphmap = new glyphMap({
  data: bikes,
  getLocationFn: (row) => [row.lon, row.lat],
  cellSize: 35,
  discretisationShape: discretisationInput, //"grid",
  //discretisationMode: "relativeToMouse",
  showLegend: false,
  interactiveCellSize: true,
  //interactiveKernelBW: true,
  //kernelBW: 2,
  interactiveZoomPan: true,
  // mapType: tile,
  // greyscale: true,
  tileWidth: 150,

  width: 600,
  height: 400,
  //   width: containerNode.offsetWidth,
  //   height: containerNode.offsetHeight,

  customMap: {
    scaleParams: [
      _setupParamFns({
        name: "heightMaxV",
        decKey: "LEFT",
        decFn: (v) => v - v / 10,
        incKey: "RIGHT",
        incFn: (v) => v + v / 10,
        resetKey: "s",
        autoscale: true,
        resetFn: (cells, global, panel) =>
          d3.max(
            cells.map((cell) =>
              cell && cell.ts ? d3.max(cell.ts.map((ts) => d3.max(ts))) : 0
            )
          ),
      }),
    ],

    //kernelSmoothProperties: ["ts", "count"],
    //kernelSmoothPropertyTypes: ["array", "value"],

    initFn: (cells, cellSize, global, panel) => {
      global.numT = d3.max(panel.data.map((row) => row.ts.length));
    },

    preAggrFn: (cells, cellSize, global, panel) => {},

    aggrFn: (cell, row, weight, global, panel) => {
      if (!cell.ts) cell.ts = [];
      const sums = [];
      const cs = [];
      cell.ts.push(row.ts);
      if (!cell.stations) cell.stations = [];
      if (!cell.stations.includes(row.name)) cell.stations.push(row.name);
    },

    postAggrFn: (cells, cellSize, global, panel) => {},

    preDrawFn: (cells, cellSize, ctx, global, panel) => {
      // ctx.fillStyle = "#fff9";
      // ctx.fillRect(0, 0, panel.getWidth(), panel.getHeight());

      global.heightScale = d3
        .scaleLinear()
        .domain([0, global.heightMaxV])
        .range([0, cellSize])
        .clamp(true);
    },

    drawFn: (cell, x, y, cellSize, ctx, global, panel) => {
      //console.log(x, y);
      if (cell && cell.ts && !cell.new) {
        const padding = 4;
        const incX = (cellSize - padding * 2) / global.numT;

        // get current zoom
        let zoom = Math.log2(panel.getTransform().k).toFixed(2);
        const mouse = [global.mouseX, global.mouseY];
        // console.log("locafn", panel.screenToCoord(mouse));
        // console.log("locafn", global.mouseCell.getXCentre());
        // console.log(zoom);

        //test screen coord
        // const scoord = panel.screenToCoord([0, cellSize]);
        // console.log("screencord", scoord);

        //draw cell background
        const boundary = cell.getBoundary(padding);
        ctx.fillStyle = "#cccb";
        if (zoom >= 12) ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.moveTo(boundary[0][0], boundary[0][1]);
        for (let i = 1; i < boundary.length; i++)
          ctx.lineTo(boundary[i][0], boundary[i][1]);
        ctx.closePath();
        ctx.fill();

        for (const ts of cell.ts) {
          ctx.beginPath();
          ctx.strokeStyle = "#8557";
          if (zoom >= 12) ctx.strokeStyle = "red";
          for (let i = 0; i < ts.length; i++) {
            ctx.lineTo(
              x - cellSize / 2 + padding + incX * i,
              y + cellSize / 2 - padding - global.heightScale(ts[i])
            );
          }
          ctx.stroke();
        }
      }
    },
    postDrawFn: (cells, cellSize, ctx, global, panel) => {},
    // tooltipTextFn: (cell) => {
    //   return cell.stations ? cell.stations : "";
    // },
  },
});

invalidation.then(() => {
  console.log("invalidated!");
});

display(glyphmap);
return {glyphmap};
}});

define({id: "42ca5e5a", body: () => {
// const canvas = glyphmap.querySelector("canvas");

// const container = document.querySelector("#map");

// if (!container.contains(glyphmap)) {
//   // If not, append the glyphMap instance to zthe container
//   container.appendChild(glyphmap);
// }

// const ctx = canvas.getContext("2d");

// invalidation.then(() => ctx.clearRect(0, 0, canvas.width, canvas.height));
}});

</script>
<div id="observablehq-center">
<main id="observablehq-main" class="observablehq">
<div id="cell-4b2ac85f" class="observablehq observablehq--block"></div>
<h1 id="gridded" tabindex="-1"><a class="observablehq-header-anchor" href="#gridded">Gridded</a></h1>
<div id="cell-ef8c2df1" class="observablehq observablehq--block"></div>
<div id="map" style="background: grey;"></div>
<!-- <div class="grid grid-cols-1" style="max-height:60px;">
  <div class="card" style="padding:6px;">
  <span id="cell-5f55c7c5" class="observablehq--loading"></span>
  </div>
</div> -->
<div id="cell-1c6a8776" class="observablehq observablehq--block"></div>
<div id="cell-b3d45b28" class="observablehq observablehq--block"></div>
<div id="cell-6cd10b9d" class="observablehq observablehq--block"></div>
<div id="cell-42ca5e5a" class="observablehq observablehq--block"></div>
</main>
</div>
